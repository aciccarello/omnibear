{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/li/lib/index.js","webpack:///./node_modules/micropub-helper/src/dependencies-browser.js","webpack:///./node_modules/micropub-helper/src/lib/append-query-string.js","webpack:///./node_modules/micropub-helper/src/lib/object-to-form-data.js","webpack:///./node_modules/micropub-helper/src/lib/rel-scraper.js","webpack:///./node_modules/micropub-helper/src/main.js","webpack:///./node_modules/parse-uri/index.js","webpack:///./node_modules/qs/lib/formats.js","webpack:///./node_modules/qs/lib/index.js","webpack:///./node_modules/qs/lib/parse.js","webpack:///./node_modules/qs/lib/stringify.js","webpack:///./node_modules/qs/lib/utils.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/background.js","webpack:///./src/background/authentication.js","webpack:///./src/browser.js","webpack:///./src/constants.js","webpack:///./src/util/log.js","webpack:///./src/util/micropub.js","webpack:///./src/util/settings.js","webpack:///./src/util/url.js","webpack:///./src/util/utils.js"],"names":["authTabId","handleMessage","request","sender","action","handleBeginAuth","payload","updateFocusedWindow","tab","id","pageEntry","selectedEntry","selectEntry","clearEntry","localStorage","setItem","domain","metadata","authEndpoint","tokenEndpoint","micropub","__browser__","tabs","create","url","authUrl","tabId","JSON","stringify","entry","removeItem","handleTabChange","changeInfo","isAuthRedirect","code","setTimeout","sendAuthStatusUpdate","then","remove","catch","err","message","sendMessage","startsWith","runtime","onMessage","addListener","onUpdated","contextMenus","title","contexts","onclick","browser","window","open","windows","width","height","type","left","fetchToken","fetchSyndicationTargets","options","me","getItem","micropubEndpoint","getToken","token","Error","error","query","syndicateTo","response","Array","isArray","chrome","NOTE","REPLY","BOOKMARK","REPOST","LIKE","SETTINGS","LOGS","LOGIN","MESSAGE","PAGE_REPLY","ITEM_REPLY","MESSAGE_SUCCESS","MESSAGE_ERROR","DEFAULT_REACJI","getLogs","clearLogs","info","warning","INFO","WARNING","ERROR","log","parse","saveLog","formatDate","date","day","getDate","getMonth","getFullYear","time","getHours","getMinutes","getSeconds","getMilliseconds","append","data","logsEnabled","length","unshift","timestamp","Date","serializeError","push","stack","trim","split","settings","debugLog","postNote","postReply","postBookmark","postLike","postRepost","Micropub","clientId","redirectUri","state","scope","aliases","h","content","category","tagsArray","slug","syndicateList","name","getSettings","saveSettings","saveAuthenticationDetails","getSyndicateOptions","KEYS","DEFAULT_SETTINGS","defaultToCurrentPage","autoSlug","closeAfterPosting","reacji","clean","forEach","key","getParamFromUrl","getParamFromUrlString","cleanParams","paramsToQueryString","getUrlOrigin","cleanUrl","paramName","params","matches","filter","param","value","substr","decodeURIComponent","i","parts","join","protocol","host","port","base","path","queryKey","openLink","clone","getAuthTab","logout","generateSlug","getPageUrl","sanitizeMicropubError","e","preventDefault","target","href","obj","Promise","resolve","reject","items","map","item","NON_ALPHANUM","FROM","TO","formatted","toLocaleLowerCase","replace","l","RegExp","charAt","splice","get","Number","status","config","method","headers","Accept","statusText"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;;AAEA,MAAM,KAA4B;AAClC,+EAA+E,oCAAO,UAAU;AAAA;AAAA;AAAA;AAAA,oGAAC;AACjG;;AAEA,CAAC;AACD;AACA,sBAAsB,8BAA8B,SAAS;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,IAAI;AACb;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;;AAEX;AACA,6CAA6C;AAC7C,OAAO;;AAEP;AACA;AACA;;AAEA,CAAC;;;;;;;;;;;;;AC1FD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgE;AAC7B;AACuB;AACc;AACC;;;;;;;;;;;;;ACJzE;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;ACvBA;AAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACpCD;AAAA;AAA+C;AAC/C,gBAAgB,qDAAoB;AACpC,mBAAmB,wDAAuB;AAC1C,oBAAoB,yDAAwB;AAC5C,yBAAyB,8DAA6B;AACtD,0BAA0B,+DAA8B;AACxD,yBAAyB,gDAAe;AACxC,IAAI,sDAAqB;AACzB,oBAAoB,sDAAqB;AACzC;AACA,IAAI,uDAAsB;AAC1B,qBAAqB,uDAAsB;AAC3C;AACA,IAAI,iDAAgB;AACpB,eAAe,iDAAgB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,4CAA4C,0BAA0B;AACtE;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oEAAoE,UAAU;;AAE9E;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEe,uEAAQ,EAAC;;;;;;;;;;;;;;ACviBZ;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;AC7Ba;;AAEb;AACA;;AAEA,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACzBa;;AAEb,gBAAgB,mBAAO,CAAC,uDAAa;AACrC,YAAY,mBAAO,CAAC,+CAAS;AAC7B,cAAc,mBAAO,CAAC,mDAAW;;AAEjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,+CAAS;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gCAAgC;;AAExE;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AClPa;;AAEb,YAAY,mBAAO,CAAC,+CAAS;AAC7B,cAAc,mBAAO,CAAC,mDAAW;AACjC;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtRa;;AAEb;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,kDAAkD,EAAE;AACpD;AACA,SAAS;AACT;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,OAAO,WAAW,aAAa;AACjD;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1OA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;ACnBA;;;;AACA;;AACA;;AACA;;AACA;;;;AAEA,IAAIA,YAAY,IAAhB;;AAEA,SAASC,aAAT,CAAuBC,OAAvB,EAAgCC,MAAhC,EAAwC;AACtC,UAAQD,QAAQE,MAAhB;AACE,SAAK,YAAL;AACEC,sBAAgBH,QAAQI,OAAxB;AACA;AACF,SAAK,cAAL;AACEC,0BACEJ,OAAOK,GAAP,CAAWC,EADb,EAEEP,QAAQI,OAAR,CAAgBI,SAFlB,EAGER,QAAQI,OAAR,CAAgBK,aAHlB;AAKA;AACF,SAAK,cAAL;AACEC,kBAAYV,QAAQI,OAApB;AACA;AACF,SAAK,aAAL;AACEO;A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","file":"background.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/background.js\");\n","(function (name, definition, context) {\n\n  //try CommonJS, then AMD (require.js), then use global.\n\n  if (typeof module != 'undefined' && module.exports) module.exports = definition();\n  else if (typeof context['define'] == 'function' && context['define']['amd']) define(definition);\n  else context[name] = definition();\n\n})('li', function () {\n  // compile regular expressions ahead of time for efficiency\n  var relsRegExp = /^;\\s*([^\"=]+)=(?:\"([^\"]+)\"|([^\";,]+)(?:[;,]|$))/;\n  var sourceRegExp = /^<([^>]*)>/;\n  var delimiterRegExp = /^\\s*,\\s*/;\n\n  return {\n    parse: function (linksHeader, options) {\n      var match;\n      var source;\n      var rels;\n      var extended = options && options.extended || false;\n      var links = [];\n\n      while (linksHeader) {\n        linksHeader = linksHeader.trim();\n\n        // Parse `<link>`\n        source = sourceRegExp.exec(linksHeader);\n        if (!source) break;\n\n        var current = {\n          link: source[1]\n        };\n\n        // Move cursor\n        linksHeader = linksHeader.slice(source[0].length);\n\n        // Parse `; attr=relation` and `; attr=\"relation\"`\n\n        var nextDelimiter = linksHeader.match(delimiterRegExp);\n        while(linksHeader && (!nextDelimiter || nextDelimiter.index > 0)) {\n          match = relsRegExp.exec(linksHeader);\n          if (!match) break;\n\n          // Move cursor\n          linksHeader = linksHeader.slice(match[0].length);\n          nextDelimiter = linksHeader.match(delimiterRegExp);\n\n\n          if (match[1] === 'rel' || match[1] === 'rev') {\n            // Add either quoted rel or unquoted rel\n            rels = (match[2] || match[3]).split(/\\s+/);\n            current[match[1]] = rels;\n          } else {\n            current[match[1]] = match[2] || match[3];\n          }\n        }\n\n        links.push(current);\n        // Move cursor\n        linksHeader = linksHeader.replace(delimiterRegExp, '');\n      }\n\n      if (!extended) {\n        return links.reduce(function(result, currentLink) {\n          if (currentLink.rel) {\n            currentLink.rel.forEach(function(rel) {\n              result[rel] = currentLink.link;\n            });\n          }\n          return result;\n        }, {});\n      }\n\n      return links;\n    },\n    stringify: function (params) {\n      var grouped = Object.keys(params).reduce(function(grouped, key) {\n        grouped[params[key]] = grouped[params[key]] || [];\n        grouped[params[key]].push(key);\n        return grouped;\n      }, {});\n\n      var entries = Object.keys(grouped).reduce(function(result, link) {\n        return result.concat('<' + link + '>; rel=\"' + grouped[link].join(' ') + '\"');\n      }, []);\n\n      return entries.join(', ');\n    }\n  };\n\n}, this);\n","export { parse as qsParse, stringify as qsStringify } from 'qs';\nexport { default as li } from 'li';\nexport { default as relScraper } from './lib/rel-scraper';\nexport { default as objectToFormData } from './lib/object-to-form-data';\nexport { default as appendQueryString } from './lib/append-query-string';\n","export default function appendQueryString(url, queryVars) {\n  const firstSeperator = url.indexOf('?') == -1 ? '?' : '&';\n  let queryStringParts = [];\n  for (var key in queryVars) {\n    if (Array.isArray(queryVars[key])) {\n      queryVars[key].forEach(val => {\n        queryStringParts.push(key + '[]=' + encodeURIComponent(val));\n      });\n    } else {\n      queryStringParts.push(key + '=' + encodeURIComponent(queryVars[key]));\n    }\n  }\n  const queryString = queryStringParts.join('&');\n  return url + firstSeperator + queryString;\n}\n","// const FormData = require('form-data');\n\nexport default function objectToFormData(\n  object,\n  formData = new FormData(),\n  name = false,\n) {\n  Object.keys(object).forEach(key => {\n    const data = object[key];\n    if (name) {\n      key = name + '[' + key + ']';\n    }\n    if (Array.isArray(data)) {\n      data.forEach(arrayItem => {\n        const arrayData = {};\n        arrayData[key + '[]'] = arrayItem;\n        formData = objectToFormData(arrayData, formData);\n      });\n    } else {\n      formData.append(key, data);\n    }\n  });\n  return formData;\n}\n","export default function(htmlString, url) {\n  let rels = {};\n  let baseUrl = url;\n\n  const doc = new DOMParser().parseFromString(htmlString, 'text/html');\n  const baseEl = doc.querySelector('base[href]');\n  const relEls = doc.querySelectorAll('[rel][href]');\n\n  if (baseEl) {\n    const value = baseEl.getAttribute('href');\n    const urlObj = new URL(value, url);\n    baseUrl = urlObj.toString();\n  }\n\n  if (relEls.length) {\n    relEls.forEach(relEl => {\n      const names = relEl\n        .getAttribute('rel')\n        .toLowerCase()\n        .split('\\\\s+');\n      const value = relEl.getAttribute('href');\n      if (names.length && value !== null) {\n        names.forEach(name => {\n          if (!rels[name]) {\n            rels[name] = [];\n          }\n          const url = new URL(value, baseUrl).toString();\n          if (rels[name].indexOf(url) === -1) {\n            rels[name].push(url);\n          }\n        });\n      }\n    });\n  }\n\n  return rels;\n}\n","import * as dependencies from './dependencies';\nconst qsParse = dependencies.qsParse;\nconst relScraper = dependencies.relScraper;\nconst qsStringify = dependencies.qsStringify;\nconst objectToFormData = dependencies.objectToFormData;\nconst appendQueryString = dependencies.appendQueryString;\nconst linkHeaderParser = dependencies.li.parse;\nif (dependencies.FormData && !global.FormData) {\n  global.FormData = dependencies.FormData;\n}\nif (dependencies.DOMParser && !global.DOMParser) {\n  global.DOMParser = dependencies.DOMParser;\n}\nif (dependencies.URL && !global.URL) {\n  global.URL = dependencies.URL;\n}\n\nconst defaultSettings = {\n  me: '',\n  scope: 'post create delete update',\n  token: '',\n  authEndpoint: '',\n  tokenEndpoint: '',\n  micropubEndpoint: '',\n};\n\nconst micropubError = (message, status = null, error = null) => {\n  return {\n    message: message,\n    status: status,\n    error: error,\n  };\n};\n\nclass Micropub {\n  constructor(userSettings = {}) {\n    this.options = Object.assign({}, defaultSettings, userSettings);\n\n    // Bind all the things\n    this.create = this.create.bind(this);\n    this.update = this.update.bind(this);\n    this.delete = this.delete.bind(this);\n    this.undelete = this.undelete.bind(this);\n    this.postMicropub = this.postMicropub.bind(this);\n    this.checkRequiredOptions = this.checkRequiredOptions.bind(this);\n    this.getAuthUrl = this.getAuthUrl.bind(this);\n    this.getEndpointsFromUrl = this.getEndpointsFromUrl.bind(this);\n  }\n\n  /**\n   * Checks to see if the given options are set\n   * @param  {array} requirements An array of option keys to check\n   * @return {object}             An object with boolean pass property and array missing property listing missing options\n   */\n  checkRequiredOptions(requirements) {\n    let missing = [];\n    let pass = true;\n    for (var i = 0; i < requirements.length; i++) {\n      const optionName = requirements[i];\n      const option = this.options[optionName];\n      if (!option) {\n        pass = false;\n        missing.push(optionName);\n      }\n    }\n    return {\n      pass: pass,\n      missing: missing,\n    };\n  }\n\n  /**\n   * Get the various endpoints needed from the given url\n   * @param  {string} url The url to scrape\n   * @return {Promise}    Passes an object of endpoints on success: auth, token and micropub\n   */\n  getEndpointsFromUrl(url) {\n    return new Promise((fulfill, reject) => {\n      let endpoints = {\n        micropub: null,\n        authorization_endpoint: null,\n        token_endpoint: null,\n      };\n      // Get the base url from the given url\n      let baseUrl = url;\n      // Fetch the given url\n      fetch(url, { credentials: 'omit' })\n        .then(res => {\n          if (!res.ok) {\n            return reject(micropubError('Error getting page', res.status));\n          }\n          baseUrl = res.url;\n\n          // Check for endpoints in headers\n          const linkHeaders = res.headers.get('link');\n          if (linkHeaders) {\n            const links = linkHeaderParser(linkHeaders);\n            Object.keys(endpoints).forEach(key => {\n              if (links[key]) {\n                endpoints[key] = links[key];\n              }\n            });\n          }\n\n          return res.text();\n        })\n        .then(html => {\n          // Get rel links\n          const rels = relScraper(html, baseUrl);\n\n          // Save necessary endpoints.\n          this.options.me = url;\n          if (rels) {\n            Object.keys(endpoints).forEach(key => {\n              if (rels[key] && rels[key][0]) {\n                endpoints[key] = rels[key][0];\n              }\n            });\n          }\n\n          if (\n            endpoints.micropub &&\n            endpoints.authorization_endpoint &&\n            endpoints.token_endpoint\n          ) {\n            this.options.micropubEndpoint = endpoints.micropub;\n            this.options.tokenEndpoint = endpoints.token_endpoint;\n            this.options.authEndpoint = endpoints.authorization_endpoint;\n            return fulfill({\n              auth: this.options.authEndpoint,\n              token: this.options.tokenEndpoint,\n              micropub: this.options.micropubEndpoint,\n            });\n          }\n\n          return reject(micropubError('Error getting microformats data'));\n        })\n        .catch(err => reject(micropubError('Error fetching url', null, err)));\n    });\n  }\n\n  getToken(code) {\n    return new Promise((fulfill, reject) => {\n      const requirements = this.checkRequiredOptions([\n        'me',\n        'clientId',\n        'redirectUri',\n        'tokenEndpoint',\n      ]);\n      if (!requirements.pass) {\n        return reject(\n          micropubError(\n            'Missing required options: ' + requirements.missing.join(', '),\n          ),\n        );\n      }\n\n      const data = {\n        grant_type: 'authorization_code',\n        me: this.options.me,\n        code: code,\n        client_id: this.options.clientId,\n        redirect_uri: this.options.redirectUri,\n      };\n\n      const request = {\n        method: 'POST',\n        credentials: 'omit',\n        body: qsStringify(data),\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n          Accept: 'application/json, application/x-www-form-urlencoded',\n        },\n        // mode: 'cors',\n      };\n      // This could maybe use the postMicropub method\n      fetch(this.options.tokenEndpoint, request)\n        .then(res => {\n          if (!res.ok) {\n            return reject(micropubError('Error getting token', res.status));\n          }\n          const contentType = res.headers.get('Content-Type');\n          if (contentType && contentType.indexOf('application/json') === 0) {\n            return res.json();\n          } else {\n            return res.text();\n          }\n        })\n        .then(result => {\n          // Parse the response from the indieauth server\n          if (typeof result === 'string') {\n            result = qsParse(result);\n          }\n          if (result.error_description) {\n            return reject(micropubError(result.error_description));\n          } else if (result.error) {\n            return reject(micropubError(result.error));\n          }\n          if (!result.me || !result.scope || !result.access_token) {\n            return reject(\n              micropubError(\n                'The token endpoint did not return the expected parameters',\n              ),\n            );\n          }\n          // Check me is the same (removing any trailing slashes)\n          if (\n            result.me &&\n            result.me.replace(/\\/+$/, '') !==\n              this.options.me.replace(/\\/+$/, '')\n          ) {\n            return reject(micropubError('The me values did not match'));\n          }\n          // Check scope matches (not reliable)\n          // console.log(result.scope);\n          // console.log(this.options.scope);\n          // if (result.scope && result.scope !== this.options.scope) {\n          //   reject('The scope values did not match');\n          // }\n          // Successfully got the token\n          this.options.token = result.access_token;\n          fulfill(result.access_token);\n        })\n        .catch(err =>\n          reject(micropubError('Error requesting token endpoint', null, err)),\n        );\n    });\n  }\n\n  /**\n   * Get the authentication url based on the set options\n   * @return {string|boolean} The authentication url or false on missing options\n   */\n  getAuthUrl() {\n    return new Promise((fulfill, reject) => {\n      let requirements = this.checkRequiredOptions(['me', 'state']);\n      if (!requirements.pass) {\n        return reject(\n          micropubError(\n            'Missing required options: ' + requirements.missing.join(', '),\n          ),\n        );\n      }\n      this.getEndpointsFromUrl(this.options.me)\n        .then(() => {\n          let requirements = this.checkRequiredOptions([\n            'me',\n            'state',\n            'scope',\n            'clientId',\n            'redirectUri',\n          ]);\n          if (!requirements.pass) {\n            return reject(\n              micropubError(\n                'Missing required options: ' + requirements.missing.join(', '),\n              ),\n            );\n          }\n          const authParams = {\n            me: this.options.me,\n            client_id: this.options.clientId,\n            redirect_uri: this.options.redirectUri,\n            response_type: 'code',\n            scope: this.options.scope,\n            state: this.options.state,\n          };\n\n          fulfill(this.options.authEndpoint + '?' + qsStringify(authParams));\n        })\n        .catch(err =>\n          reject(micropubError('Error getting auth url', null, err)),\n        );\n    });\n  }\n\n  verifyToken() {\n    return new Promise((fulfill, reject) => {\n      const requirements = this.checkRequiredOptions([\n        'token',\n        'micropubEndpoint',\n      ]);\n      if (!requirements.pass) {\n        return reject(\n          micropubError(\n            'Missing required options: ' + requirements.missing.join(', '),\n          ),\n        );\n      }\n\n      const request = {\n        method: 'GET',\n        credentials: 'omit',\n        headers: {\n          Authorization: 'Bearer ' + this.options.token,\n        },\n      };\n\n      fetch(this.options.micropubEndpoint, request)\n        .then(res => {\n          if (res.ok) {\n            return fulfill(true);\n          } else {\n            return reject(micropubError('Error verifying token', res.status));\n          }\n        })\n        .catch(err =>\n          reject(micropubError('Error verifying token', null, err)),\n        );\n    });\n  }\n\n  create(post, type = 'json') {\n    return this.postMicropub(post, type);\n  }\n\n  update(url, update) {\n    return this.postMicropub(\n      Object.assign(\n        {\n          action: 'update',\n          url: url,\n        },\n        update,\n      ),\n    );\n  }\n\n  delete(url) {\n    return this.postMicropub({\n      action: 'delete',\n      url: url,\n    });\n  }\n\n  undelete(url) {\n    return this.postMicropub({\n      action: 'undelete',\n      url: url,\n    });\n  }\n\n  postMicropub(object, type = 'json') {\n    return new Promise((fulfill, reject) => {\n      const requirements = this.checkRequiredOptions([\n        'token',\n        'micropubEndpoint',\n      ]);\n      if (!requirements.pass) {\n        return reject(\n          micropubError(\n            'Missing required options: ' + requirements.missing.join(', '),\n          ),\n        );\n      }\n\n      let request = {\n        method: 'POST',\n        credentials: 'omit',\n      };\n\n      if (type == 'json') {\n        request.body = JSON.stringify(object);\n        request.headers = {\n          Authorization: 'Bearer ' + this.options.token,\n          'Content-Type': 'application/json',\n          Accept: 'application/json, application/x-www-form-urlencoded',\n        };\n      } else if (type == 'form') {\n        request.body = qsStringify(object, { arrayFormat: 'brackets' });\n        request.headers = {\n          Authorization: 'Bearer ' + this.options.token,\n          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n          Accept: 'application/json, application/x-www-form-urlencoded',\n        };\n      } else if (type == 'multipart') {\n        request.body = objectToFormData(object);\n        request.headers = {\n          Authorization: 'Bearer ' + this.options.token,\n          Accept: 'application/json, application/x-www-form-urlencoded',\n        };\n      }\n\n      fetch(this.options.micropubEndpoint, request)\n        .then(res => {\n          if (!res.ok) {\n            return reject(\n              micropubError('Error with micropub request', res.status),\n            );\n          }\n          const location =\n            res.headers.get('Location') || res.headers.get('location');\n          if (location) {\n            return fulfill(location);\n          }\n          const contentType = res.headers.get('Content-Type');\n          if (contentType && contentType.indexOf('application/json') === 0) {\n            return res.json();\n          } else {\n            return res.text();\n          }\n        })\n        .then(result => {\n          if (typeof result === 'string') {\n            result = qsParse(result);\n          }\n          if (result.error_description) {\n            return reject(micropubError(result.error_description));\n          } else if (result.error) {\n            return reject(micropubError(result.error));\n          } else {\n            return fulfill(result);\n          }\n        })\n        .catch(err =>\n          reject(micropubError('Error sending request', null, err)),\n        );\n    });\n  }\n\n  postMedia(file) {\n    return new Promise((fulfill, reject) => {\n      const requirements = this.checkRequiredOptions([\n        'token',\n        'mediaEndpoint',\n      ]);\n      if (!requirements.pass) {\n        return reject(\n          micropubError(\n            'Missing required options: ' + requirements.missing.join(', '),\n          ),\n        );\n      }\n\n      let request = {\n        method: 'POST',\n        credentials: 'omit',\n        body: objectToFormData({ file: file }),\n        headers: {\n          Authorization: 'Bearer ' + this.options.token,\n          Accept: '*/*',\n        },\n      };\n\n      fetch(this.options.mediaEndpoint, request)\n        .then(res => {\n          if (res.status !== 201) {\n            return reject(micropubError('Error creating media', res.status));\n          }\n          const location =\n            res.headers.get('Location') || res.headers.get('location');\n          if (location) {\n            return fulfill(location);\n          } else {\n            return reject(\n              micropubError(\n                'Media endpoint did not return a location',\n                res.status,\n              ),\n            );\n          }\n        })\n        .catch(err => reject(micropubError('Error sending request')));\n    });\n  }\n\n  query(type) {\n    return new Promise((fulfill, reject) => {\n      const requirements = this.checkRequiredOptions([\n        'token',\n        'micropubEndpoint',\n      ]);\n      if (!requirements.pass) {\n        return reject(\n          micropubError(\n            'Missing required options: ' + requirements.missing.join(', '),\n          ),\n        );\n      }\n\n      const url = appendQueryString(this.options.micropubEndpoint, { q: type });\n\n      const request = {\n        method: 'GET',\n        credentials: 'omit',\n        headers: {\n          Authorization: 'Bearer ' + this.options.token,\n          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n          Accept: 'application/json',\n        },\n        // mode: 'cors',\n      };\n\n      fetch(url, request)\n        .then(res => {\n          if (!res.ok) {\n            return reject(micropubError('Error getting ' + type, res.status));\n          }\n          return res.json();\n        })\n        .then(json => fulfill(json))\n        .catch(err =>\n          reject(micropubError('Error getting ' + type, null, err)),\n        );\n    });\n  }\n\n  querySource(url, properties = []) {\n    return new Promise((fulfill, reject) => {\n      const requirements = this.checkRequiredOptions([\n        'token',\n        'micropubEndpoint',\n      ]);\n      if (!requirements.pass) {\n        return reject(\n          micropubError(\n            'Missing required options: ' + requirements.missing.join(', '),\n          ),\n        );\n      }\n\n      url = appendQueryString(this.options.micropubEndpoint, {\n        q: 'source',\n        url: url,\n        properties: properties,\n      });\n\n      const request = {\n        method: 'GET',\n        credentials: 'omit',\n        headers: {\n          Authorization: 'Bearer ' + this.options.token,\n          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',\n          Accept: 'application/json',\n        },\n        // mode: 'cors',\n      };\n\n      fetch(url, request)\n        .then(res => {\n          if (!res.ok) {\n            return reject(micropubError('Error getting source', res.status));\n          }\n          return res.json();\n        })\n        .then(json => fulfill(json))\n        .catch(err => reject(micropubError('Error getting source', null, err)));\n    });\n  }\n}\n\nexport default Micropub;\n","'use strict'\n\nmodule.exports = function parseURI (str, opts) {\n  opts = opts || {}\n\n  var o = {\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n    q: {\n      name: 'queryKey',\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }\n\n  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)\n  var uri = {}\n  var i = 14\n\n  while (i--) uri[o.key[i]] = m[i] || ''\n\n  uri[o.q.name] = {}\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) uri[o.q.name][$1] = $2\n  })\n\n  return uri\n}\n","'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar util = require('./utils');\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = util.assign(\n    {\n        'default': Format.RFC3986,\n        formatters: {\n            RFC1738: function (value) {\n                return replace.call(value, percentTwenties, '+');\n            },\n            RFC3986: function (value) {\n                return String(value);\n            }\n        }\n    },\n    Format\n);\n","'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n","'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\n// This is what browsers will submit when the ✓ character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the ✓ character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset, 'key');\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset, 'value');\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(val);\n        }\n\n        if (val && options.comma && val.indexOf(',') > -1) {\n            val = val.split(',');\n        }\n\n        if (has.call(obj, key)) {\n            obj[key] = utils.combine(obj[key], val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n    var leaf = val;\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = [].concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (!options.parseArrays && cleanRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = options.depth > 0 && brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    return {\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar formats = require('./formats');\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) {\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint';\n};\n\nvar stringify = function stringify(\n    object,\n    prefix,\n    generateArrayPrefix,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    formatter,\n    encodeValuesOnly,\n    charset\n) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = obj.join(',');\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (isArray(obj)) {\n            pushToArray(values, stringify(\n                obj[key],\n                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        } else {\n            pushToArray(values, stringify(\n                obj[key],\n                prefix + (allowDots ? '.' + key : '[' + key + ']'),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        }\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if (opts && 'indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('✓')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, decoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar encode = function encode(str, defaultEncoder, charset) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    merge: merge\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import __browser__ from './browser';\nimport {getParamFromUrl} from './util/url';\nimport {getAuthTab} from './util/utils';\nimport {fetchToken, fetchSyndicationTargets} from './background/authentication';\nimport {info, error} from './util/log';\n\nlet authTabId = null;\n\nfunction handleMessage(request, sender) {\n  switch (request.action) {\n    case 'begin-auth':\n      handleBeginAuth(request.payload);\n      break;\n    case 'focus-window':\n      updateFocusedWindow(\n        sender.tab.id,\n        request.payload.pageEntry,\n        request.payload.selectedEntry,\n      );\n      break;\n    case 'select-entry':\n      selectEntry(request.payload);\n      break;\n    case 'clear-entry':\n      clearEntry();\n  }\n}\n\nfunction handleBeginAuth(payload) {\n  localStorage.setItem('domain', payload.domain);\n  localStorage.setItem('authEndpoint', payload.metadata.authEndpoint);\n  localStorage.setItem('tokenEndpoint', payload.metadata.tokenEndpoint);\n  localStorage.setItem('micropubEndpoint', payload.metadata.micropub);\n  __browser__.tabs.create({url: payload.authUrl}, tab => {\n    authTabId = tab.id;\n  });\n}\n\nfunction updateFocusedWindow(tabId, pageEntry, selectedEntry) {\n  localStorage.setItem('pageEntry', JSON.stringify(pageEntry));\n  localStorage.setItem('pageTabId', tabId);\n  if (selectedEntry) {\n    selectEntry(selectedEntry);\n  } else {\n    clearEntry();\n  }\n}\n\nfunction selectEntry(entry) {\n  localStorage.setItem('itemEntry', JSON.stringify(entry));\n}\n\nfunction clearEntry() {\n  localStorage.removeItem('itemEntry');\n}\n\nfunction handleTabChange(tabId, changeInfo, tab) {\n  if (tabId !== authTabId || !isAuthRedirect(changeInfo)) {\n    return;\n  }\n  var code = getParamFromUrl('code', changeInfo.url);\n  setTimeout(() => {\n    sendAuthStatusUpdate(`Retrieving access token…`);\n    fetchToken(code)\n      .then(() => {\n        sendAuthStatusUpdate('Fetching syndication targets…');\n        return fetchSyndicationTargets();\n      })\n      .then(() => {\n        sendAuthStatusUpdate(`Authentication complete.`);\n        authTabId = null;\n        setTimeout(() => {\n          __browser__.tabs.remove(tab.id);\n        }, 500);\n      })\n      .catch(err => {\n        error(err.message, err);\n      });\n  }, 500);\n}\n\nfunction sendAuthStatusUpdate(message) {\n  info(message);\n  getAuthTab().then(tab => {\n    __browser__.tabs.sendMessage(tab.id, {\n      action: 'auth-status-update',\n      payload: {message},\n    });\n  });\n}\n\nfunction isAuthRedirect(changeInfo) {\n  var url = 'https://omnibear.com/auth/success';\n  return changeInfo.url && changeInfo.url.startsWith(url);\n}\n\n__browser__.runtime.onMessage.addListener(handleMessage);\n__browser__.tabs.onUpdated.addListener(handleTabChange);\n__browser__.contextMenus.create({\n  title: 'Reply to entry',\n  contexts: ['page', 'selection'],\n  onclick: function() {\n    if (typeof browser === 'undefined') {\n      // Chrome\n      window.open(\n        'index.html?type=reply',\n        'extension_popup',\n        'width=450,height=580,status=no,scrollbars=yes,resizable=no,top=80,left=2000',\n      );\n    } else {\n      // Firefox (and others?)\n      browser.windows.create({\n        url: 'index.html?type=reply',\n        width: 450,\n        height: 580,\n        type: 'panel',\n        left: 2000,\n      });\n    }\n  },\n});\n","import __browser__ from '../browser';\nimport micropub from '../util/micropub';\nimport {getAuthTab, logout} from '../util/utils';\nimport {info, warning, error} from '../util/log';\n\nexport function fetchToken(code) {\n  micropub.options.me = localStorage.getItem('domain');\n  micropub.options.tokenEndpoint = localStorage.getItem('tokenEndpoint');\n  micropub.options.micropubEndpoint = localStorage.getItem('micropubEndpoint');\n  return micropub\n    .getToken(code)\n    .then(function(token) {\n      if (!token) {\n        throw new Error(\n          'Token not found in token endpoint response. Missing expected field `access_token`',\n        );\n      }\n      localStorage.setItem('token', token);\n      micropub.options.token = token;\n    })\n    .catch(function(err) {\n      error('Error fetching token', err);\n      getAuthTab().then(tab => {\n        __browser__.tabs.sendMessage(tab.id, {\n          action: 'fetch-token-error',\n          payload: {\n            error: err,\n          },\n        });\n        logout();\n      });\n    });\n}\n\nexport function fetchSyndicationTargets() {\n  return micropub.query('syndicate-to').then(response => {\n    const syndicateTo = response['syndicate-to'];\n    info('Syndication targets retreived', syndicateTo);\n    if (Array.isArray(syndicateTo)) {\n      localStorage.setItem('syndicateTo', JSON.stringify(syndicateTo));\n    } else {\n      warning(\n        `Syndication targets not in array format. Saving as empty array.`,\n      );\n      localStorage.setItem('syndicateTo', JSON.stringify([]));\n    }\n  });\n}\n","if (typeof browser === 'undefined' && typeof chrome !== 'undefined') {\n  // Chrome\n  var browser = chrome;\n}\n\nexport default browser;\n","export const NOTE = 'note';\nexport const REPLY = 'reply';\nexport const BOOKMARK = 'bookmark';\nexport const REPOST = 'repost';\nexport const LIKE = 'like';\nexport const SETTINGS = 'settings';\nexport const LOGS = 'logs';\nexport const LOGIN = 'login';\nexport const MESSAGE = 'message';\n\nexport const PAGE_REPLY = 'page-reply';\nexport const ITEM_REPLY = 'item-reply';\n\nexport const MESSAGE_SUCCESS = 'success';\nexport const MESSAGE_ERROR = 'error';\n\nexport const DEFAULT_REACJI = ['👍', '👎', '🎉', '😆', '😢', '😠'];\n","import {getSettings} from './settings';\n\nconst INFO = 'info';\nconst WARNING = 'warning';\nconst ERROR = 'error';\n\nexport function getLogs() {\n  const log = JSON.parse(localStorage.getItem('log'));\n  if (log) {\n    return log;\n  }\n  return [];\n}\n\nfunction saveLog(log) {\n  localStorage.setItem('log', JSON.stringify(log));\n}\n\nexport function clearLogs() {\n  localStorage.setItem('log', '[]');\n}\n\nfunction formatDate(date) {\n  const day = `${date.getDate()}/${date.getMonth() + 1}/${date.getFullYear()}`;\n  const time = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}.${date.getMilliseconds()}`;\n  return `${day} ${time}`;\n}\n\nfunction append(message, data, type) {\n  if (!logsEnabled() && type !== ERROR) {\n    return;\n  }\n  const log = getLogs();\n  if (log.length > 100) {\n    log.unshift();\n  }\n  const entry = {\n    message,\n    type,\n    timestamp: formatDate(new Date()),\n  };\n  if (data) {\n    if (data instanceof Error) {\n      entry.data = serializeError(data);\n    } else {\n      entry.data = data;\n    }\n  }\n  log.push(entry);\n  saveLog(log);\n}\n\nfunction serializeError(err) {\n  return {\n    message: err.message,\n    stack: err.stack.trim().split('\\n'),\n  };\n}\n\nexport function info(message, data) {\n  append(message, data, INFO);\n}\nexport default info;\n\nexport function warning(message, data) {\n  append(message, data, WARNING);\n}\n\nexport function error(message, data) {\n  append(message, data, ERROR);\n}\n\nfunction logsEnabled() {\n  const settings = getSettings();\n  return settings.debugLog;\n}\n","import Micropub from 'micropub-helper';\n\nconst micropub = new Micropub({\n  clientId: 'https://omnibear.com',\n  redirectUri: 'https://omnibear.com/auth/success/',\n  state: 'very-secret-omnibear-state',\n  me: localStorage.getItem('domain'),\n  authEndpoint: localStorage.getItem('authEndpoint'),\n  tokenEndpoint: localStorage.getItem('tokenEndpoint'),\n  micropubEndpoint: localStorage.getItem('micropubEndpoint'),\n  token: localStorage.getItem('token'),\n  scope: 'create delete update',\n});\nexport default micropub;\n\nexport function postNote(entry, aliases) {\n  return micropub.create(\n    {\n      h: 'entry',\n      content: entry.content,\n      category: entry.tagsArray,\n      [aliases.slug]: entry.slug,\n      [aliases.syndicateTo]: entry.syndicateList,\n    },\n    'form'\n  );\n}\n\nexport function postReply(entry, url, aliases) {\n  return micropub.create(\n    {\n      h: 'entry',\n      'in-reply-to': url,\n      content: entry.content,\n      category: entry.tagsArray,\n      [aliases.slug]: entry.slug,\n      [aliases.syndicateTo]: entry.syndicateList,\n    },\n    'form'\n  );\n}\n\nexport function postBookmark(entry, url, aliases) {\n  return micropub.create(\n    {\n      h: 'entry',\n      'bookmark-of': url,\n      name: entry.title,\n      content: entry.content,\n      category: entry.tagsArray,\n      [aliases.slug]: entry.slug,\n      [aliases.syndicateTo]: entry.syndicateList,\n    },\n    'form'\n  );\n}\n\nexport function postLike(url) {\n  const entry = {\n    h: 'entry',\n    'like-of': url,\n  };\n  return micropub.create(entry, 'form');\n}\n\nexport function postRepost(url) {\n  const entry = {\n    h: 'entry',\n    'repost-of': url,\n  };\n  return micropub.create(entry, 'form');\n}\n","import micropub from './micropub';\nimport {DEFAULT_REACJI} from '../constants';\n\nconst KEYS = [\n  'defaultToCurrentPage',\n  'autoSlug',\n  'closeAfterPosting',\n  'debugLog',\n  'reacji',\n  'slug',\n  'syndicateTo',\n];\n\nconst DEFAULT_SETTINGS = {\n  defaultToCurrentPage: false,\n  autoSlug: false,\n  closeAfterPosting: true,\n  debugLog: false,\n  reacji: DEFAULT_REACJI,\n  slug: 'mp-slug',\n  syndicateTo: 'mp-syndicate-to',\n};\n\nexport function getSettings() {\n  const settings = JSON.parse(localStorage.getItem('settings'));\n  if (settings) {\n    return settings;\n  }\n  return DEFAULT_SETTINGS;\n}\n\nexport function saveSettings(settings) {\n  const clean = {};\n  KEYS.forEach(key => {\n    clean[key] = settings[key];\n  });\n  localStorage.setItem('settings', JSON.stringify(clean));\n}\n\nexport function saveAuthenticationDetails(domain, token, micropubEndpoint) {\n  if (domain) {\n    localStorage.setItem('domain', domain);\n    micropub.options.me = domain;\n  }\n  if (token) {\n    localStorage.setItem('token', token);\n    micropub.options.token = token;\n  }\n  if (micropubEndpoint) {\n    localStorage.setItem('micropubEndpoint', micropubEndpoint);\n    micropub.options.micropubEndpoint = micropubEndpoint;\n  }\n}\n\nexport function getSyndicateOptions() {\n  const options = localStorage.getItem('syndicateTo');\n  if (options && options !== 'undefined') {\n    return JSON.parse(options);\n  } else {\n    // Fix bad data from omnibear v1.0.0 bug that saved 'undefined' to localStorage\n    localStorage.setItem('syndicateTo', '[]');\n    return [];\n  }\n}\n","import parseUri from 'parse-uri';\n\nexport function getParamFromUrl(paramName, url) {\n  var params = url.split('?')[1] || '';\n  return getParamFromUrlString(paramName, params);\n}\n\nexport function getParamFromUrlString(paramName, params) {\n  var matches = params\n    .split('&')\n    .filter(param => param.startsWith(`${paramName}=`));\n  if (matches && matches.length) {\n    var value = matches[0].substr(paramName.length + 1);\n    return decodeURIComponent(value);\n  } else {\n    return null;\n  }\n}\n\nexport function cleanParams(params) {\n  const clean = {};\n  for (let i in params) {\n    if (!i.startsWith('utm_')) {\n      clean[i] = params[i];\n    }\n  }\n  return clean;\n}\n\nexport function paramsToQueryString(params) {\n  const parts = [];\n  for (let i in params) {\n    parts.push(`${i}=${params[i]}`);\n  }\n  if (!parts.length) {\n    return '';\n  }\n  return `?${parts.join('&')}`;\n}\n\nexport function getUrlOrigin(url) {\n  const parts = parseUri(url);\n  return [\n    parts.protocol,\n    '://',\n    parts.host,\n    parts.port ? `:${parts.port}` : '',\n  ].join('');\n}\n\n// strip hashes and utm_* query params\nexport function cleanUrl(url) {\n  const parts = parseUri(url);\n  const base = [\n    parts.protocol,\n    '://',\n    parts.host,\n    parts.port ? `:${parts.port}` : '',\n    parts.path,\n    paramsToQueryString(cleanParams(parts.queryKey)),\n  ].join('');\n  return base;\n}\n","import __browser__ from '../browser';\n\nexport function openLink(e) {\n  e.preventDefault();\n  if (e.target.href) {\n    __browser__.tabs.create({url: e.target.href});\n  }\n}\n\nexport function clone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function getAuthTab() {\n  return new Promise(function(resolve, reject) {\n    __browser__.tabs.query(\n      {url: 'https://omnibear.com/auth/success*'},\n      function(tabs) {\n        if (tabs.length) {\n          resolve(tabs[0]);\n        } else {\n          reject('Auth tab not found');\n        }\n      },\n    );\n  });\n}\n\nexport function logout() {\n  const items = [\n    'token',\n    'domain',\n    'authEndpoint',\n    'tokenEndpoint',\n    'micropubEndpoint',\n  ];\n  items.map(item => localStorage.removeItem(item));\n}\n\nconst NON_ALPHANUM = /[^A-Za-z0-9-]/g;\nconst FROM = 'áäâàãåčçćďéěëèêẽĕȇęėíìîïňñóöòôõøðřŕšťúůüùûýÿžþÞĐđßÆa·/_,:;';\nconst TO = 'aaaaaacccdeeeeeeeeeeiiiinnooooooorrstuuuuuyyzbBDdBAa------';\n\nexport function generateSlug(content) {\n  let formatted = content.toLocaleLowerCase().trim();\n  formatted = formatted.replace(/\\s/g, '-');\n  for (let i = 0, l = FROM.length; i < l; i++) {\n    formatted = formatted.replace(\n      new RegExp(FROM.charAt(i), 'g'),\n      TO.charAt(i),\n    );\n  }\n  formatted = formatted.replace(NON_ALPHANUM, '');\n  formatted = formatted.replace(/--+/g, '-');\n  const parts = formatted.split('-');\n  return parts.splice(0, 6).join('-');\n}\n\nexport function getPageUrl() {\n  return new Promise(resolve => {\n    var tabId = localStorage.getItem('pageTabId');\n    __browser__.tabs.get(Number(tabId), tab => {\n      resolve(tab.url);\n    });\n  });\n}\n\nexport function sanitizeMicropubError(error) {\n  if (!error) {\n    return null;\n  }\n  const clean = {\n    message: error.message,\n    status: Number(error.status),\n  };\n  const config = error.config || (error.error && error.error.config);\n  if (!config) {\n    return clean;\n  }\n  clean.data = config.data;\n  clean.method = config.method;\n  clean.url = config.url;\n  if (config.headers) {\n    clean.headers = {\n      Accept: config.headers.Accept,\n      'Content-Type': config.headers['Content-Type'],\n    };\n  }\n  if (config.response) {\n    clean.response = {\n      data: config.response.data,\n      status: config.response.status,\n      statusText: config.response.statusText,\n    };\n  }\n  return clean;\n}\n"],"sourceRoot":""}