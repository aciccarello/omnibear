{"version":3,"sources":["webpack:///page.js","webpack:///webpack/bootstrap e27daccc41ebc45526d0","webpack:///./src/page.js","webpack:///./~/microformat-shiv/microformat-shiv.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","15","_interopRequireDefault","obj","default","_microformatShiv","_microformatShiv2","clearItem","currentItem","chrome","runtime","sendMessage","action","removeHighlight","console","log","classList","remove","className","handleMessage","request","sender","sendResponse","document","body","addEventListener","e","el","target","contains","tagName","parentElement","mf","node","url","items","length","properties","payload","add","onMessage","addListener","17","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","undefined","this","addV1","parser","options","maps","Array","isArray","version","livingStandard","Parser","rootPrefix","propertyPrefixes","excludeTags","rels","init","rootNode","baseUrl","filters","textFormat","dateFormat","overlappingVersions","impliedPropertiesByVersion","parseLatLonGeo","lang","rootID","errors","noContentErr","out","formatEmpty","data","mergeOptions","getDOMContext","hasMicroformats","prepareDOM","newRootNode","findFilterNodes","walkRoot","domUtils","canCloneDocument","clearUpDom","findRels","push","formatError","getParent","getParentTreeWalk","count","classItems","x","findRootNodes","getAttributeList","utils","startWith","appendCount","key","indexOf","relCount","countRels","isMicroformat","classes","getTopMostNode","getUfClassNames","forEach","map","JSON","parse","stringify","recursive","parentNode","nodeName","nodes","baseTag","href","location","querySelector","getAttribute","path","newDocument","getNodePath","cloneDocument","getNodeByPath","addIncludes","rel-urls","isString","createNode","y","getMapping","v1Name","hasAttributeValue","clone","appendChild","shouldInclude","uf","type","includeRoot","arr","getNodesByAttribute","child","context","children","walkTree","concat","getChildren","itemRootID","createUfObject","typeVersion","walkChildren","impliedRules","getFirstAncestorAttribute","cleanUfObject","ufName","parentClasses","rootItem","propertyName","propertyVersion","z","addedAsRoot","text","removePropPrefix","impliedValueRule","getValue","hasRootID","isAllowedPropertyVersion","appendRootID","getPValue","getEValue","getUValue","getDTValue","valueParse","getValueClass","getValueTitle","getAttrValFromTagList","html","expandURLs","resolve","fromValue","format","dates","isDuration","isTime","times","parseAmPmTime","ISODate","toString","id","rootids","hasAttribute","setAttribute","join","propertyType","trim","parseText","concatFragments","getNodesByAttributeValue","hasHClass","ufNameArr","classNames","item","prop","propName","v2Name","impiedRel","hasTagName","split","isLowerCase","subTree","a","getV2RootName","findRelImpied","b","names","isOnlyWhiteSpace","altValue","microformat","prefix","substr","attrName","attr","err","removeRootIds","removeAttribute","removeIncludes","constructor","impliedBackwardComp","impliedhFeedTitle","impliedName","impliedPhoto","impliedUrl","impliedValue","impliedDate","impliedGeo","getImpliedProperty","getNameAttr","photo","getPhotoAttr","getURLAttr","newDate","dateTimeUnion","tagList","getAttrFunction","descendant","getSingleDescendantOfType","getSingleDescendant","getAltValue","parentPropertyName","title","textContent","geoPair","parts","longitude","latitude","valid","replace","parseFloat","isNumber","hasProperties","addAttributeIncludes","addClassIncludes","attributeName","idList","apppendInclude","include","getElementById","markIncludeChildren","removeChild","relList","resolved","relUrl","getRelProperties","media","hreflang","relAlt","hasRel","isNaN","isFinite","propertyIsEnumerable","isFunction","test","toLowerCase","replaceCharAt","index","character","trimWhitespace","collapseWhiteSpace","sortObjects","reverse","getDOMParser","DOMParser","Components","createInstance","interfaces","nsIDOMParser","domParser","parseFromString","nodeType","ownerDocument","innerText","innerHTML","attributeValue","docNode","selector","attList","querySelectorAll","tagNames","attrValue","getDescendant","onlyOfType","countAll","countOfType","childNode","newNode","cloneNode","removeDescendantsByTagName","getElementsByTagName","elements","getElementText","getOrderedAttributes","nodeStr","outerHTML","attrs","attributes","indexNum","sort","decodeEntities","doc","createTextNode","nodeValue","implementation","createHTMLDocument","importNode","documentElement","replaceChild","getChildIndex","parent","childNodes","createElement","createNodeWithText","_domParser","_html","_nodes","_baseNode","_linkNode","URL","URI","dateString","clear","setFormatSep","arguments","clearDate","clearTime","clearTimeZone","setAutoProfileState","dY","dM","dD","dDDD","tH","tM","tS","tD","tzH","tzM","tzPN","autoProfile","sep","dsep","tsep","tzsep","tzZulu","setFormat","tzArray","position","datePart","timePart","timeZonePart","toUpperCase","substring","parseDate","parseTime","parseTimeZone","match","timeString","toTimeString","output","hasFullDate","hasDate","hasTime","hasTimeZone","hasAM","hasPM","removeAMPM","parseInt","date","time","isodate","isotime","charAt","splitTimeAndZone","chars","slice","blockLevelTags","walkTreeForText","normalise","clonedNode","trimmedNode","formatText","j","selfClosingElt","walkTreeForHtml","containerNode","post-office-box","street-address","extended-address","locality","region","postal-code","country-name","fn","adr","agent","bday","class","category","email","geo","label","logo","mailer","honorific-prefix","given-name","additional-name","family-name","honorific-suffix","nickname","note","org","p-organization-name","p-organization-unit","rev","role","sequence","sort-string","sound","tel","tz","uid","entry-title","entry-summary","entry-content","published","updated","author","summary","dtstart","dtend","description","duration","contact","organizer","attendee","attach","status","rdate","rrule","lister","dtlisted","dtexpired","price","listing","entry","source-org","dateline","item-license","principles","childStructure","organization-name","organization-unit","brand","review","identifier","ingredient","yield","instructions","nutrition","education","experience","skill","affiliation","rating","average","best","worst","votes","reviewer","dtreviewer","friend","acquaintance","met","co-worker","colleague","co-resident","neighbor","sibling","spouse","kin","muse","crush","sweetheart","me","license","nofollow","tag","self","bookmark","home","directory","enclosure","pronunciation","payment","External","DOMParser_proto","real_parseFromString","textHTML","textXML","htmlElInnerHTML","er","markup","doc_el","first_el","firstElementChild","childElementCount","localName"],"mappings":"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","file":"page.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 15);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 15:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _microformatShiv = __webpack_require__(17);\n\nvar _microformatShiv2 = _interopRequireDefault(_microformatShiv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(function () {\n  var currentItem = void 0;\n  var className = '__omnibear-selected-item';\n\n  function clearItem() {\n    if (currentItem) {\n      chrome.runtime.sendMessage({\n        action: 'clear-entry'\n      });\n      removeHighlight();\n    }\n  }\n\n  function removeHighlight() {\n    if (currentItem) {\n      console.log('removing class');\n      currentItem.classList.remove(className);\n      currentItem = null;\n    } else {\n      console.log('no currentItem');\n    }\n  }\n\n  document.body.addEventListener('click', function () {\n    clearItem();\n  });\n\n  document.body.addEventListener('contextmenu', function (e) {\n    clearItem();\n    var el = e.target;\n    while (!el.classList.contains('h-entry') && el.tagName != 'BODY') {\n      el = el.parentElement;\n    }\n\n    if (!el.classList.contains('h-entry')) {\n      return;\n    }\n    var mf = _microformatShiv2.default.get({ node: el });\n    var url = void 0;\n    if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n      url = mf.items[0].properties.url[0];\n    }\n    if (url) {\n      chrome.runtime.sendMessage({\n        action: 'select-entry',\n        payload: {\n          url: url\n        }\n      });\n      el.classList.add(className);\n      currentItem = el;\n    }\n  });\n\n  function handleMessage(request, sender, sendResponse) {\n    switch (request.action) {\n      case 'remove-entry-highlight':\n        removeHighlight();\n        break;\n    }\n  }\n  chrome.runtime.onMessage.addListener(handleMessage);\n})();\n\n/***/ }),\n\n/***/ 17:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '–', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// page.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 15);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e27daccc41ebc45526d0","import microformat from 'microformat-shiv';\n\n(function () {\n  let currentItem;\n  const className = '__omnibear-selected-item';\n\n  function clearItem() {\n    if (currentItem) {\n      chrome.runtime.sendMessage({\n        action: 'clear-entry',\n      });\n      removeHighlight();\n    }\n  }\n\n  function removeHighlight() {\n    if (currentItem) {\n      console.log('removing class');\n      currentItem.classList.remove(className);\n      currentItem = null;\n    } else {\n      console.log('no currentItem');\n    }\n  }\n\n  document.body.addEventListener('click', function () {\n    clearItem();\n  });\n\n  document.body.addEventListener('contextmenu', function (e) {\n    clearItem();\n    let el = e.target;\n    while(!el.classList.contains('h-entry') && el.tagName != 'BODY') {\n      el = el.parentElement;\n    }\n\n    if (!el.classList.contains('h-entry')) {\n      return;\n    }\n    const mf = microformat.get({node: el});\n    let url;\n    if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n      url = mf.items[0].properties.url[0];\n    }\n    if (url) {\n      chrome.runtime.sendMessage({\n        action: 'select-entry',\n        payload: {\n          url: url,\n        },\n      });\n      el.classList.add(className);\n      currentItem = el;\n    }\n  });\n\n  function handleMessage(request, sender, sendResponse) {\n    switch (request.action) {\n      case 'remove-entry-highlight':\n        removeHighlight();\n        break;\n    }\n  }\n  chrome.runtime.onMessage.addListener(handleMessage);\n}());\n\n\n\n// WEBPACK FOOTER //\n// ./src/page.js","/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '–', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/microformat-shiv/microformat-shiv.js\n// module id = 17\n// module chunks = 2"],"sourceRoot":""}