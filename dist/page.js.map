{"version":3,"sources":["webpack:///page.js","webpack:///webpack/bootstrap b73782e03f7e08247ffa?ee52*","webpack:///./~/microformat-shiv/microformat-shiv.js","webpack:///./src/page.js","webpack:///./src/page/entry.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","16","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","undefined","this","addV1","parser","options","maps","Array","isArray","add","version","livingStandard","Parser","rootPrefix","propertyPrefixes","excludeTags","rels","init","rootNode","document","baseUrl","filters","textFormat","dateFormat","overlappingVersions","impliedPropertiesByVersion","parseLatLonGeo","lang","rootID","errors","noContentErr","out","formatEmpty","data","mergeOptions","getDOMContext","hasMicroformats","prepareDOM","length","newRootNode","findFilterNodes","walkRoot","items","domUtils","canCloneDocument","clearUpDom","findRels","push","formatError","getParent","node","getParentTreeWalk","count","classItems","x","findRootNodes","getAttributeList","utils","startWith","appendCount","key","indexOf","relCount","countRels","isMicroformat","classes","getTopMostNode","getUfClassNames","forEach","map","properties","JSON","parse","stringify","recursive","parentNode","nodeName","nodes","baseTag","href","location","e","querySelector","getAttribute","path","newDocument","getNodePath","cloneDocument","getNodeByPath","addIncludes","rel-urls","isString","createNode","y","getMapping","v1Name","hasAttributeValue","clone","appendChild","shouldInclude","uf","type","includeRoot","arr","classList","getNodesByAttribute","child","context","children","walkTree","concat","getChildren","obj","itemRootID","createUfObject","typeVersion","walkChildren","impliedRules","getFirstAncestorAttribute","cleanUfObject","ufName","parentClasses","rootItem","propertyName","propertyVersion","z","addedAsRoot","text","removePropPrefix","impliedValueRule","getValue","hasRootID","isAllowedPropertyVersion","appendRootID","className","getPValue","getEValue","getUValue","getDTValue","valueParse","getValueClass","getValueTitle","getAttrValFromTagList","html","expandURLs","url","resolve","fromValue","format","dates","isDuration","isTime","times","parseAmPmTime","ISODate","toString","id","rootids","hasAttribute","setAttribute","join","propertyType","trim","parseText","concatFragments","getNodesByAttributeValue","hasHClass","ufNameArr","classNames","item","prop","propName","v2Name","impiedRel","hasTagName","split","isLowerCase","subTree","a","getV2RootName","findRelImpied","b","names","isOnlyWhiteSpace","altValue","microformat","prefix","substr","attrName","attr","err","removeRootIds","removeAttribute","removeIncludes","constructor","impliedBackwardComp","impliedhFeedTitle","impliedName","impliedPhoto","impliedUrl","impliedValue","impliedDate","impliedGeo","getImpliedProperty","getNameAttr","photo","getPhotoAttr","getURLAttr","newDate","dateTimeUnion","tagList","getAttrFunction","descendant","getSingleDescendantOfType","getSingleDescendant","getAltValue","parentPropertyName","title","textContent","geoPair","parts","longitude","latitude","valid","replace","parseFloat","isNumber","hasProperties","addAttributeIncludes","addClassIncludes","attributeName","idList","apppendInclude","include","getElementById","markIncludeChildren","removeChild","relList","resolved","relUrl","getRelProperties","media","hreflang","relAlt","hasRel","isNaN","isFinite","propertyIsEnumerable","isFunction","test","toLowerCase","replaceCharAt","index","character","trimWhitespace","collapseWhiteSpace","sortObjects","reverse","getDOMParser","DOMParser","Components","createInstance","interfaces","nsIDOMParser","domParser","parseFromString","nodeType","ownerDocument","innerText","innerHTML","attributeValue","docNode","selector","attList","querySelectorAll","tagNames","tagName","attrValue","getDescendant","onlyOfType","countAll","countOfType","childNode","newNode","cloneNode","removeDescendantsByTagName","getElementsByTagName","elements","getElementText","getOrderedAttributes","nodeStr","outerHTML","attrs","attributes","indexNum","sort","decodeEntities","doc","createTextNode","nodeValue","implementation","createHTMLDocument","importNode","documentElement","replaceChild","getChildIndex","parent","childNodes","createElement","createNodeWithText","_domParser","_html","_nodes","_baseNode","_linkNode","URL","URI","dateString","clear","setFormatSep","arguments","clearDate","clearTime","clearTimeZone","setAutoProfileState","dY","dM","dD","dDDD","tH","tM","tS","tD","tzH","tzM","tzPN","autoProfile","sep","dsep","tsep","tzsep","tzZulu","setFormat","tzArray","position","datePart","timePart","timeZonePart","toUpperCase","substring","parseDate","parseTime","parseTimeZone","match","timeString","toTimeString","output","hasFullDate","hasDate","hasTime","hasTimeZone","hasAM","hasPM","removeAMPM","parseInt","date","time","isodate","isotime","charAt","splitTimeAndZone","chars","slice","blockLevelTags","walkTreeForText","normalise","clonedNode","trimmedNode","formatText","j","selfClosingElt","walkTreeForHtml","containerNode","post-office-box","street-address","extended-address","locality","region","postal-code","country-name","fn","adr","agent","bday","class","category","email","geo","label","logo","mailer","honorific-prefix","given-name","additional-name","family-name","honorific-suffix","nickname","note","org","p-organization-name","p-organization-unit","rev","role","sequence","sort-string","sound","tel","tz","uid","entry-title","entry-summary","entry-content","published","updated","author","summary","dtstart","dtend","description","duration","contact","organizer","attendee","attach","status","rdate","rrule","lister","dtlisted","dtexpired","price","listing","entry","source-org","dateline","item-license","principles","childStructure","organization-name","organization-unit","brand","review","identifier","ingredient","yield","instructions","nutrition","education","experience","skill","affiliation","rating","average","best","worst","votes","reviewer","dtreviewer","friend","acquaintance","met","co-worker","colleague","co-resident","neighbor","sibling","spouse","kin","muse","crush","sweetheart","me","license","nofollow","tag","self","bookmark","home","directory","enclosure","pronunciation","payment","External","DOMParser_proto","real_parseFromString","textHTML","textXML","htmlElInnerHTML","er","markup","doc_el","first_el","firstElementChild","childElementCount","localName","20","_entry","sendFocusMessage","chrome","runtime","sendMessage","action","payload","selectedEntry","getCurrentItemUrl","body","addEventListener","clearItem","focusClickedEntry","hidden","window","6","_interopRequireDefault","default","currentItem","removeHighlight","remove","CLASS_NAME","currentItemUrl","hostname","findTweet","target","findHEntry","element","el","contains","parentElement","mf","_microformatShiv2","_microformatShiv"],"mappings":"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","file":"page.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 20);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 16:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '–', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _entry = __webpack_require__(6);\n\n(function () {\n\n  document.body.addEventListener('click', _entry.clearItem);\n\n  document.body.addEventListener('contextmenu', _entry.focusClickedEntry);\n\n  // function handleMessage(request, sender, sendResponse) {\n  //   switch (request.action) {\n  //     case 'remove-entry-highlight':\n  //       removeHighlight();\n  //       break;\n  //   }\n  // }\n  // chrome.runtime.onMessage.addListener(handleMessage);\n\n  if (!document.hidden) {\n    sendFocusMessage();\n  }\n  window.addEventListener('focus', sendFocusMessage);\n\n  function sendFocusMessage() {\n    chrome.runtime.sendMessage({\n      action: 'focus-window',\n      payload: {\n        selectedEntry: (0, _entry.getCurrentItemUrl)()\n      }\n    });\n  }\n})();\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearItem = clearItem;\nexports.removeHighlight = removeHighlight;\nexports.focusClickedEntry = focusClickedEntry;\nexports.getCurrentItemUrl = getCurrentItemUrl;\n\nvar _microformatShiv = __webpack_require__(16);\n\nvar _microformatShiv2 = _interopRequireDefault(_microformatShiv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CLASS_NAME = '__omnibear-selected-item';\nvar currentItem = void 0;\nvar currentItemUrl = void 0;\n\nfunction clearItem() {\n  if (currentItem) {\n    chrome.runtime.sendMessage({\n      action: 'clear-entry'\n    });\n    removeHighlight();\n  }\n}\n\nfunction removeHighlight() {\n  if (currentItem) {\n    currentItem.classList.remove(CLASS_NAME);\n    currentItem = null;\n    currentItemUrl = null;\n  }\n}\n\nfunction focusClickedEntry(e) {\n  clearItem();\n  var element = void 0;\n  var url = void 0;\n  var entry = void 0;\n  if (document.location.hostname === 'twitter.com') {\n    entry = findTweet(e.target);\n  } else {\n    entry = findHEntry(e.target);\n  }\n\n  if (!entry.url) {\n    return;\n  }\n  chrome.runtime.sendMessage({\n    action: 'select-entry',\n    payload: { url: entry.url }\n  });\n  entry.element.classList.add(CLASS_NAME);\n  currentItem = entry.element;\n  currentItemUrl = entry.url;\n}\n\nfunction findTweet(el) {\n  while (!el.classList.contains('tweet') && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n\n  if (!el.classList.contains('tweet')) {\n    return {};\n  }\n\n  var url = 'https://twitter.com' + el.getAttribute('data-permalink-path');\n  return {\n    element: el,\n    url: url\n  };\n}\n\nfunction findHEntry(el) {\n  while (!el.classList.contains('h-entry') && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n\n  if (!el.classList.contains('h-entry')) {\n    return {};\n  }\n\n  var mf = _microformatShiv2.default.get({ node: el });\n  var url = void 0;\n  if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n    url = mf.items[0].properties.url[0];\n  }\n\n  return {\n    element: el,\n    url: url\n  };\n}\n\nfunction getCurrentItemUrl() {\n  return currentItemUrl;\n}\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// page.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b73782e03f7e08247ffa","/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '–', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/microformat-shiv/microformat-shiv.js\n// module id = 16\n// module chunks = 2","import {clearItem, removeHighlight, focusClickedEntry, getCurrentItemUrl} from './page/entry';\n\n(function () {\n\n  document.body.addEventListener('click', clearItem);\n\n  document.body.addEventListener('contextmenu', focusClickedEntry);\n\n  // function handleMessage(request, sender, sendResponse) {\n  //   switch (request.action) {\n  //     case 'remove-entry-highlight':\n  //       removeHighlight();\n  //       break;\n  //   }\n  // }\n  // chrome.runtime.onMessage.addListener(handleMessage);\n\n  if (!document.hidden) {\n    sendFocusMessage();\n  }\n  window.addEventListener('focus', sendFocusMessage);\n\n  function sendFocusMessage() {\n    chrome.runtime.sendMessage({\n      action: 'focus-window',\n      payload: {\n        selectedEntry: getCurrentItemUrl(),\n      },\n    });\n  }\n}());\n\n\n\n// WEBPACK FOOTER //\n// ./src/page.js","import microformat from 'microformat-shiv';\n\nconst CLASS_NAME = '__omnibear-selected-item';\nlet currentItem;\nlet currentItemUrl;\n\nexport function clearItem() {\n  if (currentItem) {\n    chrome.runtime.sendMessage({\n      action: 'clear-entry',\n    });\n    removeHighlight();\n  }\n}\n\nexport function removeHighlight() {\n  if (currentItem) {\n    currentItem.classList.remove(CLASS_NAME);\n    currentItem = null;\n    currentItemUrl = null;\n  }\n}\n\nexport function focusClickedEntry(e) {\n  clearItem();\n  let element;\n  let url;\n  let entry;\n  if (document.location.hostname === 'twitter.com') {\n    entry = findTweet(e.target);\n  } else {\n    entry = findHEntry(e.target);\n  }\n\n  if (!entry.url) {\n    return;\n  }\n  chrome.runtime.sendMessage({\n    action: 'select-entry',\n    payload: { url: entry.url },\n  });\n  entry.element.classList.add(CLASS_NAME);\n  currentItem = entry.element;\n  currentItemUrl = entry.url;\n}\n\nfunction findTweet(el) {\n  while(!el.classList.contains('tweet') && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n\n  if (!el.classList.contains('tweet')) {\n    return {};\n  }\n\n  const url = `https://twitter.com${el.getAttribute('data-permalink-path')}`;\n  return {\n    element: el,\n    url,\n  };\n}\n\nfunction findHEntry(el) {\n  while(!el.classList.contains('h-entry') && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n\n  if (!el.classList.contains('h-entry')) {\n    return {};\n  }\n\n  const mf = microformat.get({node: el});\n  let url;\n  if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n    url = mf.items[0].properties.url[0];\n  }\n\n  return {\n    element: el,\n    url\n  };\n}\n\nexport function getCurrentItemUrl() {\n  return currentItemUrl;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/page/entry.js"],"sourceRoot":""}